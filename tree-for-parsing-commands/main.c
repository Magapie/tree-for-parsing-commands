/**
* Демонстрация работы парсера команд.
* Данный код сопоставляет тестовую команду и соответстующую ей функцию
* после чего выполняет эту функцию.
* Парсер строит следующее дерево:
* Узел дерева хранит символ.
* Вершинами дерева являются все возможные первые символы команд.
* Если узел дерева соединен с другим и его уровень ровно на единицу больше,
* значит символ в этой вершине может идти за символом узла, уровень которого
* на единицу меньше.
* Если команда заканчивается каким либо символом, то соответсвующий ей узел
* будет так же хранить ссылку на функцию, соответсвующую данной команде
* 
* Все фукнции имеют единый формат и получают на вход int arc, char* argv[]
*/


#include <stdio.h>
#include <string.h>

#include "commands/commands.h" // заданные команды и соответствующие функции
#include "commandsParser.h"    // парсер, строящий дерево и выполняющий команды


int main() {
    int argc = 5;                                             // 
    char* argv[] = { "Hello", "my", "name", "is", "John" };   // количество аргументов и сами аргументы, задано так лишь для удобства демонстрации
    Command* commandsArr = buildCommands();                   // построение удобных структур для дальнейшей работы, где каждой команде соответствует функция
    Node* baseNode = createTree(commandsArr);                 // построение дерева, по которому будет производиться поиск
    char* input = malloc(64);                                 // буфер для ввода пользователя
    while (1) {                                // цикл, в котором пользователь может протестировать поиск
        printf("Please type command: ");
        scanf("%s", input);
        if (!strcmp(input, "exit"))            // для выхода из цикла приходится писать отдельный обработчик, так как функции ничего не возвращают
            return 0;
        if (!runCommand(baseNode, input, argc, argv)) {  // поиск и выполнение команды по готовому дереву
            printf("I don't know this commmand\n");      // сигнализация о неизвестных командах
        }
    }
}